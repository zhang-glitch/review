<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    function Person() {
      this.name = 'zh'
      this.sayName = () => {
        console.log(this.name)
      }
      // return "1"   //这里返回的依旧是构造函数直接创建出来的对象。
      // return [1, 2, 3] //这里返回的是指定的对象。
    }

    Person.prototype.say = () => {
      console.log('1')
    }

    Person.prototype.friends = ['llm', 'zh']

    let p = new Person()
    console.log(p)
    // let p2 = new Person()

    // //这里直接添加了实例上方法，并不是改变原型上的方法。
    // p.say = () => {
    //   console.log('2')
    // }

    // //这里是直接作用原型上的属性，所以会改变原型上的属性。
    // p.friends.push('1')

    // console.log(p.say === p2.say)//false
    // p.say()//输出自己实例上的同名方法，并不会去原型上寻找
    // p2.say() //输出原型上的方法。
    // console.log(p.friends)
    // console.log(p2.friends)


    // console.log(p)
    // console.log(Person.prototype === Person.prototype.constructor.prototype)

    // console.log(Person)
    // console.log(Person.prototype)
    // console.log(Person.prototype.constructor)
    // console.log(p)
    // console.log(p.__proto__)
  </script>
</body>

</html>